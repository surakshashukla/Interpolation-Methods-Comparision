{
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(mice)\nlibrary(sinkr)\nlibrary(reshape2)\nlibrary(ggplot2)\n\nshinyServer(function(input, output) {\n  \n  \n  #file upload\n  \n  display_dataset <- reactive({ \n    inFile <- input$file1\n    if (is.null(inFile))\n      return(NULL)\n    \n    # function that will filter that product based on the user's input\n    data_set = head(read.csv(inFile$datapath, header=input$header, sep=input$sep, \n                            quote=input$quote) , 1000)\n    \n    data_num <- sapply(data_set, is.numeric)\n    dataset <- data_set[,data_num]\n    \n    return(dataset = dataset)\n  })\n  \n  #choose column names\n  output$choose_columns <- renderUI({\n    # If missing input, return to avoid error later in function\n    if(is.null(display_dataset()))\n      return()\n    \n    # Get the data set with the appropriate name\n    dat <- display_dataset()\n    colnames <- names(dat)\n    \n    # Create the checkboxes and select them all by default\n    checkboxGroupInput(\"columns\", \"Choose columns\", \n                       choices  = colnames,\n                       selected = colnames)\n  })\n  \n  \n  tables <- reactive({\n    if(is.null(display_dataset())){return ()}\n    \n    # Get the data set\n    dat <- display_dataset()\n    \n    # Make sure columns are correct for data set (when data set changes, the\n    # columns will initially be for the previous data set)\n    if (is.null(input$columns) || !(input$columns %in% names(dat)))\n      return()\n    \n    # Keep the selected columns\n    dat <- dat[, input$columns, drop = FALSE]\n    \n    data_table <- head(dat, 1000)\n    \n    miss_table<- as.matrix(data_table[,input$columns])\n    set.seed(1)\n    miss_table[sample(length(miss_table), 0.15*length(miss_table))] <- NaN\n    miss_table\n    \n    return(list(data_table = data_table, miss_table = miss_table))\n  })\n  \n  \n  # This reactive output contains the dataset and display the dataset in table format\n  output$table <- renderTable({\n    tables()$data_table\n  })\n  \n  output$missing_table <- renderTable({\n    tables()$miss_table\n  })\n  \n  interpolation <- reactive({\n    data_table <- tables()$miss_table\n    \n    if(input$method == 'mice.pmm'){\n      y <- mice(data_table, m = 5, method = \"pmm\")\n      interp_table = complete(y)\n    }\n    else if(input$method == 'mice.norm'){\n      y <- mice(data_table, m = 5, method = \"norm\")\n      interp_table = complete(y)\n    }\n    else if(input$method == 'mice.mean'){\n      y <- mice(data_table, m = 5, method = \"mean\")\n      interp_table = complete(y)\n    }\n    else if(input$method == 'eof'){\n      a <- eof(data_table, recursive = TRUE, method=\"svd\")\n      interp_table = eofRecon(a)\n    }\n    else{\n      interp_table = NULL\n    }\n    interp_table\n    \n  })\n  \n  error_Plot <- reactive({\n    if(is.null(interpolation()))\n      return()\n    \n    data_table <- tables()$data_table\n    inter_table <- interpolation()\n    error_table <- abs(data_table - inter_table)\n#     x <- 1:50\n#     plot(x)\n    for(i in 1:ncol(error_table)){\n      local({\n        data_col <- error_table[,i]\n        plot(data_col, col = \"red\")\n\n      })\n    }\n  })\n  \n  output$errorPlot <- renderUI({\n    \n  })\n  \n  #---------------Error plot starts-------------\n  \n  max_plots <- reactive({\n    if(is.null(interpolation()))\n      return()\n    data <- tables()$data_table\n    int <- interpolation()\n    data_sub <- data - int\n    max_plot <- ncol(data_sub)\n    return(list(data_sub = data_sub, max_plot = max_plot))\n  })\n  \n  output$plots <- renderUI({\n    if(is.null(interpolation()))\n      return()\n    max_col <- max_plots()$max_plot\n    \n    plot_output_list <- lapply(1:max_col, function(i) {\n      plotname <- paste(\"plot\", i, sep=\"\")\n      plotOutput(plotname, height = 280, width = 250)\n    })\n    \n    # Convert the list to a tagList - this is necessary for the list of items\n    # to display properly.\n    do.call(tagList, plot_output_list)\n    plot_content()\n  })\n  \n  # Call renderPlot for each one. Plots are only actually generated when they\n  # are visible on the web page.\n  plot_content <- reactive({\n    if(is.null(interpolation()))\n      return()\n    for (i in 1:max_plots()$max_plot) {\n      # Need local so that each item gets its own number. Without it, the value\n      # of i in the renderPlot() will be the same across all instances, because\n      # of when the expression is evaluated.\n      \n      local({\n        my_i <- i\n        plotname <- paste(\"plot\", my_i, sep=\"\")\n        \n        output[[plotname]] <- renderPlot({\n          data_sub <- max_plots()$data_sub\n          plot(data_sub[,my_i])\n        })\n      })\n    }\n  })\n  \n    \n    \n#     m <- data_sub$FIPS\n#     data_sub <- melt(data_sub, id.vars = m)\n#     \n#     ggplot(data_sub, aes(x=m, y=value, fill=variable)) + geom_bar(stat='identity')\n    \n\n \n  \n  \n  #------------------Error plot ends ---------------\n  \n  output$intp_table <- renderTable({\n    if(is.null(interpolation()))\n      return()\n    interpolation()\n  })\n  \n  output$sub_table <- renderTable({\n    if(is.null(interpolation()))\n      return()\n    data <- tables()$data_table\n    int <- interpolation()\n    data_sub <- data - int\n    abs(data_sub)\n  })\n  \n  output$downloadOriginalData <- downloadHandler(\n      filename ='origianl_data.csv',\n      content = function(file) {\n        write.csv(tables()$data_table, file)\n      }\n\n  )\n  \n  output$downloadInterpolatedData <- downloadHandler(\n    filename = 'interpolated_data.csv',\n    content = function(file) {\n      write.csv(interpolation(), file)\n    }\n  )\n  \n})\n",
    "created" : 1452541866018.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4049499025",
    "id" : "96709FDD",
    "lastKnownWriteTime" : 1455230339,
    "path" : "~/RFiles/InterpolationUI/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}